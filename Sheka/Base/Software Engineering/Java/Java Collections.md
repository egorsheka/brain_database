16.03.2021  13:09
Tags:  #done | #job 
____

# Java Collections
![Иерархия коллекций](https://camo.githubusercontent.com/d1629242e7255381bd3cb41c55fa3f014a7f42aac7de0b8bf00be7c4dc9df883/68747470733a2f2f692e6779617a6f2e636f6d2f63373238363239653937393732626137643731356432336332663365376235312e706e67)
## ArrayList
ArrayList - динамический массив.

- Начальная ёмкость `capacity` = 10. 

Добавление
- Увеличение происхоидт по формуле size*1.5 (size + (size >> 1))
- массив всегда перезаписывается нативным методом `System.arraycopy()`, потому что каждый раз создаётся новый массив 
- если нужно добавить коллекцию в ArrayList, то для произвотдительности нужно использовать метод `addAll()`

Удаление
- Удаление происходит со сдвигом (посредствам копирования) массива влево. Уменьшается значение переменной size.  Чтобы уменшить `capacity` надо вызвать метод `trimToSize().` Тогда будет `size`= `capacity`
- Если необходимо удалить несколько элементов, наверное не стоит делать это в цикле по условию: удобнее и безопаснее воспользоваться методом `removeAll()`.

Минусы: 
- когда происходит вставка элемента по индексу и при этом в массиве нет свободных мест, то вызов `System.arraycopy()` случится дважды: первый в `grow()`, второй в самом методе `add(index, value)`, что явно скажется на скорости всей операции добавления. 

## LinkedList 
LinkedList - двусвязный список.
Начальная ёмкость -  0 узлов.



## LinkedList vs ArrayList
Необходимо описать все процессы:
- добавление и удаление (сначала, серидины, конца)
- получение элемента с разных позиций
Для сравнения двух коллекций целесобрзней всего будет провести тесты. При ответах не забывать, что узел LinkedList длостаточно тяжелый.

## LinkedList vs ArrayDeque
This class is likely to be faster than LinkedList when used as a queue (из документации java)

---

## PriorityQueue
Priority queue represented as a balanced binary heap.
balanced binary heap:
1.  Значение в любой вершине меньше или равно, чем значения её потомков (или наборот больше или равно).
2.  Глубина всех листьев отличается не более чем на 1 слой (сбалансированное).
3.  Последний слой заполняется слева направо без «дырок».
4.  Реализовано с помощью массива.
![[Pasted image 20210323133722.png]]
![[Pasted image 20210323133353.png]]

![[Pasted image 20210323135445.png]] | ![[Pasted image 20210323135455.png]]

---
## Map

![Mastering Test Automation by - Vinod Rane: Java Maps Interface](https://1.bp.blogspot.com/-amJdIXPeQgQ/WzsP-9ImrvI/AAAAAAAAAwE/uFPAFZWRyGInO1pDkYztGg8xgMchRTJRACLcBGAs/s1600/map-interface.jpg)

## Бинарное сбалансированное дерево поиска (АВЛ)

 **Двоичное дерево поиска** - ключи удовлетворяют стандартному свойству: ключ любого узла дерева не меньше любого ключа в левом поддереве данного узла и не больше любого ключа в правом поддереве этого узла.
  ![](https://habrastorage.org/storage2/361/64a/a86/36164aa86adb86997a04077b05407f13.png)  
 **Сбалансированное дерево** -  для любого узла дерева высота его правого поддерева отличается от высоты левого поддерева не более чем на единицу.
  ![[Pasted image 20210323173034.png]]


## Красно-чёрное дерево
 **Красно-чёрное дерево** один из видов самобалансирующихся двоичных деревьев поиска.
 Достигается за счёт введения дополнительного атрибута узла дерева — «цвета(крсного и чёрного)».
Красные и черные цвета используются для упрощения навигации по дереву и его балансировки.

## АВЛ vs Красно-чёрное дерево
RB-деревья, как и AVL деревьев, являются самобалансирующимися. Оба они обеспечивают производительность поиска и вставки O(log n). Разница заключается в том, что RB-деревья гарантируют O(1) оборотов за операцию вставки. Это то, что на самом деле стоит производительности в реальных реализациях. Упрощенно говоря, RB-деревья получают это преимущество от того, что концептуально являются 2-3 деревьями, не перенося накладных расходов на динамические узловые структуры.
Поиск быстрее у AVL, вставка и удаление быстрее у RB(при этом все операции log(n)).

## TreeMap
**TreeMap** — реализация `Map` основанная на красно-чёрных деревьях, является упорядоченной. По-умолчанию, коллекция сортируется по ключам, которые имплемитируют интерфейс Comparable, но это поведение может быть настроено под конкретную задачу при помощи объекта `Comparator`, который указывается в качестве параметра при создании объекта `TreeMap`.

`equals()`и `hashCode`не попадаются в поле зрения когда имеешь дело `TreeSet`и `TreeMap`.

## HashMap
HashMap — основан на хэш-таблицах, реализует интерфейс Map (что подразумевает хранение данных в виде пар ключ/значение). Ключи и значения могут быть любых типов, в том числе и null.

### Вставка

1.  Сначала ключ проверяется на равенство null. Если это проверка вернула true, не будет пункта 2 и 3, потому как все элементы с null-ключами всегда помещаются в **table\[0\]**, но пункт 4 выполняется.
2.  Далее генерируется хэш на основе ключа. 
3.  Затем определяется позиция в массиве, куда будет помещен элемент.  
4.  Теперь, зная индекс в массиве, мы получаем список (цепочку) элементов, привязанных к этой ячейке. Хэш и ключ нового элемента поочередно сравниваются с хэшами и ключами элементов из списка и, при совпадении этих параметров, значение элемента перезаписывается. Если элементов не окзалось, то просто записывается значение в ячейку массива.
    ```
    if (e.hash == hash && (e.key == key || key.equals(e.key)))
    {
        V oldValue = e.value;
        e.value = value;
                    
        return oldValue;
    }
    ```

![](https://habrastorage.org/storage1/a86b100b/9d20ef80/354bc241/3f0fcc9a.png)

 1| HashMap | LinkedHashMap | TreeMap
---|---|---|---
Порядок хранения данных|Случайный. Нет гарантий, что порядок сохранится на протяжении времени(ведь рандомно ставятся объекты в массив и происхрдит перезапить при заполнении)|В порядке добавления|В порядке возрастания или исходя из заданного компаратора
|Время доступа к элементам |O(1) | O(1) |O(log(n))
|Имплементированные интерфейсы | Map| Map|  NavigableMap SortedMap  Map
| Имплементация на основе структуры данных| Корзины (buckets)|Корзины (buckets) |Красно-чёрное дерево (Red-Black Tree)
|Возможность работы с null-ключем | Можно|  Можно| Нельзя
|Потокобезопасна |Нет |Нет |Нет
____ 
### Links
структуры данных от sam-solutions https://web.microsoftstream.com/video/aef5c649-4cb3-4f84-8af8-2d8890d600f7
https://docs.google.com/presentation/d/1KTFHeacGlgwx-_0fzQBSsWPD97iLH_imFtcRQLmQc4U/edit#slide=id.g9979d2e04a_0_7
